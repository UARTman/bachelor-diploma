@misc{derivation_task,
	title = {Derivation task},
	url = {https://github.com/buzden/deptycheck/blob/support-polymorphic-fields/docs/source/explanation/derivation/design/derivation-task.md#parameters-of-type-type},
	journal = {Derivation task},
	month = oct,
	year = {2024},
    urldate = {2024-11-10},
}

@misc{swift_generics,
	title = {Compiling Swift Generics},
	url = {https://download.swift.org/docs/assets/generics.pdf},
    urldate = {2024-11-10},
    author = {Pestov, S.}
}

@misc{idris2_compiling2execs,
    title = {Compiling to Executables},
    url = {https://github.com/idris-lang/Idris2/blob/main/docs/source/backends/index.rst},
    urldate = {2024-11-10},
}

@inproceedings{Dalen2008IntuitionisticL,
  title={Intuitionistic Logic},
  author={Dirk van Dalen},
  year={2008},
  url={https://api.semanticscholar.org/CorpusID:267828032}
}

@inproceedings{paraskevopoulou2022computing,
  title={Computing correctly with inductive relations},
  author={Paraskevopoulou, Zoe and Eline, Aaron and Lampropoulos, Leonidas},
  booktitle={Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  pages={966--980},
  year={2022}
}

@inproceedings{viroli2000parametric,
  title={Parametric polymorphism in Java: An approach to translation based on reflective features},
  author={Viroli, Mirko and Natali, Antonio},
  booktitle={Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications},
  pages={146--165},
  year={2000}
}

@article{morrison1991ad,
  title={An ad hoc approach to the implementation of polymorphism},
  author={Morrison, Ronald and Dearle, Alan and Connor, Richard C. H. and Brown, Alfred L.},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={13},
  number={3},
  pages={342--371},
  year={1991},
  publisher={ACM New York, NY, USA}
}

@article{tanaka2018safe,
  title={Safe low-level code generation in Coq using monomorphization and monadification},
  author={Tanaka, Akira and Affeldt, Reynald and Garrigue, Jacques},
  journal={Journal of Information Processing},
  volume={26},
  pages={54--72},
  year={2018},
  publisher={Information Processing Society of Japan}
}

@inproceedings{Abel2018ExtensionsTM,
  title={Extensions to Miller ’ s Pattern Unification for Dependent Types and Records},
  author={Andreas Abel and Brigitte Pientka},
  year={2018},
  url={https://api.semanticscholar.org/CorpusID:51885863}
}


@inproceedings{abel_higher-order_2011,
	address = {Berlin, Heidelberg},
	title = {Higher-{Order} {Dynamic} {Pattern} {Unification} for {Dependent} {Types} and {Records}},
	isbn = {978-3-642-21691-6},
	abstract = {While higher-order pattern unification for the λΠ-calculus is decidable and unique unifiers exists, we face several challenges in practice: 1) the pattern fragment itself is too restrictive for many applications; this is typically addressed by solving sub-problems which satisfy the pattern restriction eagerly but delay solving sub-problems which are non-patterns until we have accumulated more information. This leads to a dynamic pattern unification algorithm. 2) Many systems implement λΠΣ calculus and hence the known pattern unification algorithms for λΠ are too restrictive.},
	booktitle = {Typed {Lambda} {Calculi} and {Applications}},
	publisher = {Springer Berlin Heidelberg},
	author = {Abel, Andreas and Pientka, Brigitte},
	editor = {Ong, Luke},
	year = {2011},
	pages = {10--26},
}

@inproceedings{pdt_twintypes,
author = {L\'{o}pez Juan, V\'{\i}ctor and Danielsson, Nils Anders},
title = {Practical dependent type checking using twin types},
year = {2020},
isbn = {9781450380515},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3406089.3409030},
doi = {10.1145/3406089.3409030},
abstract = {People writing proofs or programs in dependently typed languages can omit some function arguments in order to decrease the code size and improve readability. Type checking such a program involves filling in each of these implicit arguments in a type-correct way. This is typically done using some form of unification.  One approach to unification, taken by Agda, involves sometimes starting to unify terms before their types are known to be equal: in some cases one can make progress on unifying the terms, and then use information gleaned in this way to unify the types. This flexibility allows Agda to solve implicit arguments that are not found by several other systems. However, Agda's implementation is buggy: sometimes the solutions chosen are ill-typed, which can cause the type checker to crash.  With Gundry and McBride's twin variable technique one can also start to unify terms before their types are known to be equal, and furthermore this technique is accompanied by correctness proofs. However, so far this technique has not been tested in practice as part of a full type checker.  We have reformulated Gundry and McBride's technique without twin variables, using only twin types, with the aim of making the technique easier to implement in existing type checkers (in particular Agda). We have also introduced a type-agnostic syntactic equality rule that seems to be useful in practice. The reformulated technique has been tested in a type checker for a tiny variant of Agda. This type checker handles at least one example that Coq, Idris, Lean and Matita cannot handle, and does so in time and space comparable to that used by Agda. This suggests that the reformulated technique is usable in practice.},
booktitle = {Proceedings of the 5th ACM SIGPLAN International Workshop on Type-Driven Development},
pages = {11–23},
numpages = {13},
keywords = {dependent types, type checking, unification},
location = {Virtual Event, USA},
series = {TyDe 2020}
}
