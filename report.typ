#import "report-template.typ": *
#import "@preview/fletcher:0.5.7" as fletcher: diagram, node, edge

#import "@preview/codly:1.3.0": *
#import "@preview/codly-languages:0.1.1": *
#show: codly-init.with()

#show: idris-setup
#show: gost-732-setup

#page(margin: auto, numbering: none)[
  #set par(justify: false, first-line-indent: 0pt, leading: 0.65em, spacing: 1.2em)
  #set align(center)
  #upper[
    *
    Правительство Российской Федерации \
    Федеральное государственное автономное \
    образовательное учреждение высшего образования \
    «Национальный исследовательский университет \ «Высшая школа экономики»
    *
  ]



  Факультет компьютерных наук \
  Образовательная программа бакалавриата «Программная инженерия»

  \

  #align(left)[
    УДК 004.43
  ]

  \

  #columns(2)[
    СОГЛАСОВАНО \
    Научный руководитель, \
    профессор БК\
    «Системное программирование»\
    ФКН НИУ ВШЭ, \
    Доктор физико-математических наук \
    #underline[#"                        "] А.К. Петренко \
    "#box[#underline[#"        "]]" #underline[#"                   "] 2025 г.


    #colbreak()
    УТВЕРЖДЕНО \
    Академический руководитель \
    образовательной программы \
    "Программная инженерия", \
    старший преподаватель \
    департамента программной инженерии \
    #underline[#"                        "] Н.А. Павлочев \
    "#box[#underline[#"        "]]" #underline[#"                   "] 2025 г.
  ]

  \


  *Выпускная квалификационная работа* \
  (проектно-исследовательская)

  на тему: *"Разработка алгоритма мономорфизации нерекурсивных структур данных с зависимыми типами и его программная реализация"*

  по направлению подготовки 09.03.04 "Программная инженерия"

  \

  #align(right)[
    #block()[
      #set align(center)
      ВЫПОЛНИЛ \
      Студент группы БПИ211 \
      образовательной программы \
      09.03.04 «Программная инженерия» \
      Гусев Антон Алексеевич \
      #text(size: 9pt)[(инициалы, фамилия)\ ]
      #underline[#"                                          "] \
      #text(size: 9pt)[(подпись, дата)] \
    ]
  ]

  \ \ \ \ \

  #align(center)[Москва 2024]
]

#section("РЕФЕРАТ")[
  Полиморфизм в языках функционального программирования с зависимыми типами в большинстве случаев осуществляется путём стирания типов. При этом существуют библиотеки на языках с зависимыми типами, неспособные работать с типами, полиморфными по отношению к другим типам. При использовании таких библиотек с большинством типов-контейнеров, программисту необходимо вручную производить мономорфизацию и конвертацию этих типов. Автоматизация этого процесса позволит значительно сократить количество повторяющегося кода и облегчит переиспользование кода.

  Отчёт описывает процесс мономорфизации типов, проблематику его реализации для обобщённых алгебраических типов и зависимых типов, и процесс его реализации и тестирования в качестве метапрограммы для языка Idris2.

  Данная работа состоит из #n_pages страниц, #n_chapters глав, #n_drawings рисунка, #n_listings листингов. Использовано #n_sources источников.

  *Ключевые слова*: Функциональное программирование, теория типов, зависимые типы, Idris, мономорфизация, специализация типов, унификация, параметрический полиморфизм.
]

#toplevel-heading[ABSTRACT]

Functional languages achieve  polymorphism largely by way of type erasure. However, there exist libraries in dependently-typed languages that are unable to process types, polymorphic over other types. In order to use such libraries with most standard container types, the programmer must monomorphise the types and implement two-way conversion by hand. Automating this process will allow for drastic reduction in code repetition and make code reuse easier.

The paper describes the process of type monomorphisation, issues surrounding its implementation for generic algebraic data types and dependent types, as well as the process for implementing and testing it as an Idris2 metaprogram.

The paper contains #n_pages pages, #n_chapters chapters, #n_drawings figures, #n_listings listings. #n_sources sources are used.

*Keywords*: Functional programming, type theory, dependent types, Idris, monomorphisation, type specialisation, unification, parametric polymorphism.

#outline-page

#toplevel-heading[ТЕРМИНЫ И ОПРЕДЕЛЕНИЯ]

В настоящем отчёте о НИК применяют следующие термины с соответствующими определениями:

*Параметрический полиморфизм* -- возможность обработки нескольких типов входных данных одним и тем же фрагментом кода.

*Зависимые типы* -- типы, которые зависят от значений. Такие типы позволяют кодировать собой инварианты их значений и выражать логические утверждения. Из-за этого свойства, зависимые типы используются в некоторых интерактивных решателях теорем и функциональных языках программирования.

#toplevel-heading[ВВЕДЕНИЕ]

Во многих статически типизированных языках программирования имеется возможность обработки значений данных нескольких типов одним и тем же кодом на основе общих свойств и семантики этих типов данных -- параметрический полиморфизм. Ему противопоставляется ad-hoc полиморфизм, в котором обработка данных разных типов может иметь различную логику и семантику. Например, C++ включает в себя обе парадигмы: перегрузка функций и операторов, как и классические шаблоны, представляет собой ad-hoc полиморфизм, в то время как ограничения (constraint) и концепты (concept) представляют собой попытку формализовать ad-hoc полиморфизм шаблонов в более параметрическую форму.

Типы и функции, допускающие параметрический полиморфизм, называются обобщёнными типами/функциями (generics).

Существуют два подхода к реализации параметрического полиморфизма -- стирание типов и мономорфизация @morrison1991ad @viroli2000parametric.

При полном стирании типов большинство значений оборачиваются в универсальную структуру, которая позволяет проверять наличие их полей и методов и получать к ним доступ во время исполнения программы. Это позволяет коду, полученному в результате компиляции, принимать на вход такие структуры вместо конкретных типов. Этот подход используется в высокоуровневых языках, например, Java @viroli2000parametric.

При неполном стирании типов значения по-прежнему оборачиваются в универвальные структуры данных, но информация об их исходной типизации сохраняется в виде метаданных, доступных при компиляции (Scala) или выполнении (C\#) программы.

При мономорфизации каждый вариант полиморфного типа рассматривается как отдельный тип данных, а каждый вариант полиморфной функции -- как отдельная функция. Для каждой такой функции и для каждого метода каждого полиморфного типа генерируется отдельный код. Этот подход используется в низкоуровневых языках, например Ada и Rust.

Эти два подхода не всегда взаимоисключающие. В некоторых языках, например, Swift @swift_generics или Haskell, ограниченная мономорфизация функций применяется вместе со стиранием типов.

К таким языкам относится и язык функционального программирования с зависимыми типами Idris2. По умолчанию компилятор Idris2 генерирует промежуточный код на динамически-типизированном языке Scheme @idris2_compiling2execs.

Одна из областей применения зависимых типов -- автоматическая генерация значений сложных типов данных, например, различных файловых форматов или семантически корректных программ. Зависимые типы позволяют включить в структуры данных описание инвариантов, которым они подчиняются, и, поскольку в интуиционистской логике @Dalen2008IntuitionisticL построение равноценно доказательству, любое значение такой структуры данных будет подчиняться этим инвариантам. Такой функционал входит в состав библиотек для property-based тестирования, таких как QuickChick (для языка Coq) @paraskevopoulou2022computing и DepTyCheck (для языка Idris).

Вышеупомянутая библиотека DepTyCheck @derivation_task, в настоящий момент не поддерживают генерацию значений полиморфных типов. При их использовании пользователю приходится вручную реализовывать мономорфизированные варианты таких типов и все необходимые ему методы, действующие над ними. Это приводит к повторению кода, а также затрудняет поддержку кодовой базы и вынесение абстракций в отдельные библиотеки.

Алгоритм мономорфизации зависимых типов позволит реализовать в этих библиотеках поддержку части полиморфных типов без изменения деталей реализации или API.

Цель работы -- Разработка алгоритма мономорфизации, поддерживающего практичное подмножество нерекурсивных зависимых типов.

Задачи работы:
1. Ознакомиться с существующими алгоритмами мономорфизации типов
2. Выделить среди множества нерекурсивных зависимых типов классы типов, для которых мономорфизация возможна и практична
3. Разработать алгоритм мономорфизации для этих типов
4. Реализовать этот алгоритм в виде метапрограммы для языка Idris2
5. Произвести его тестирование

#chapter[ОБЗОР ЗАДАЧИ МОНОМОРФИЗАЦИИ]

== Представление типов в языках программирования

В основе систем типов языков функционального программирования лежит понятие алгебраического типа данных (Algebraic Data Type, ADT). В этой модели тип задаётся набором аргументов, каждый из которых является типом, и набором конструкторов -- функций, возвращающих значение типа. При этом конструкторы взаимоисключающие, т.е. каждое значение типа строго соответствует вызову конкретного конструктора с конкретным набором аргументов.

#figure(caption: "Пример ADT в Idris")[
  ```idris
  data List a = Empty | Cons a (List a)
  ```
]

Например, тип `List` описывает односвязный список, элементы которого являются значениями типа `a`. Конструктор `Empty` обозначает конец списка, а конструктор `Cons` -- его звено. При этом оба конструктора можно использовать для любого типа `a`.

=== GADT

Обобщённые алгебраические типы данных (Generic Algebraic Data Type, GADT) -- расширение ADT, которое позволяет конструкторам возвращать значения своего типа с конкретными аргументами. Язык Idris2 использует GADT в качестве основы своей системы типов.

#figure(caption: "Пример GADT в Idris")[
  ```idris
  data AList : Type -> Type where
    EmptyN : AList Nat
    EmptyS : AList String
    ConsN : Nat -> AList String -> AList Nat
    ConsS : String -> AList Nat -> AList String
  ```
]

Например, конструктор `EmptyN` возвращает значение `AList`, параметризованного не произвольным типом, а только типом `Nat`. Невозможно создать значение типа `AList`, параметризованного типом, отличным от `Nat` или `String`.

Такая абстракция позволяет накладывать на значения объявленных типов более сложные ограничения на этапе компиляции. К примеру, продемонстрированный тип `AList` описывает список, в котором чередуются числа и строки. Описать такой тип в виде ADT невозможно.

== Задача мономорфизации ADT без зависимых типов

Задачу мономорфизации простого ADT можно разделить на два этапа. Сначала происходит подстановка аргументов типа в тела конструкторов. Затем в телах конструкторов находятся все места вызова исходного типа и заменяются вызовом его мономорфного варианта.

#figure(caption: "Пример мономорфизированного ADT")[
  ```idris
  data List_String = Empty_String
                   | Cons_String String (List_String)
  data List_Nat = Empty_Nat | Cons_Nat Nat (List_Nat)
  ```
]

GADT существенно усложняют задачу мономорфизации. Во-первых, каждый конструктор может содержать свои аргументы, не связанные с аргументами типа. Во-вторых, конструкторы GADT создают варианты типа с различными наборами аргументов, и следовательно существуют наборы аргументов, для которых не все конструкторы смогут создать значение типа.

При мономорфизации GADT, простая подстановка переменных заменяется более сложным процессом. Для типа и каждого из его конструкторов определяются объявленные в них аргументы и возвращаемый тип. Далее, для каждого конструктора происходит процесс унификации -- поиска набора аргументов типа и конструктора, при котором возвращаемые типы равны.

Конструкторы, для которых такого набора нет, опускаются, так как они не могут построить вариант типа с искомыми аргументами, и, как следствие, его мономорфный вариант. Конструкторы, для которых такой набор есть, включаются в мономорфный вариант GADT с подставленными аргументами.

#figure(caption: "Пример мономорфизированного GADT")[
  ```idris
  data AList_String : Type where
    EmptyS_String : AList_String
    ConsS_String : String -> AList_Nat -> AList_String
  data AList_Nat : Type where
    EmptyN_Nat : AList_Nat
    ConsN_Nat : Nat -> AList_String -> AList_Nat
  ```
]

== Существующие исследования в области мономорфизации зависимых типов

Многие языки с зависимыми типами поддерживают опциональную или частичную мономорфизацию функций, но проблема мономорфизации типов в зависимо-типизированных языках практически не рассматривалась. В единственной известной автору работе @tanaka2018safe она встречалась как один шаг в процедуре генерации кода на низкоуровневых языках из высокоуровневого представления и не поддерживала мономорфизацию зависимых типов.

== Специфика мономорфизации зависимых типов

Мономорфизация GADT ещё сильнее усложняется добавлением зависимых типов. Зависимый тип может принимать в качестве аргумента не только другие типы, но и любые значения, включая известные только во время выполнения программы. Рассмотрим пример зависимого типа:

#figure(caption: "Пример зависимого типа в Idris")[
  ```idris
  data Vect : Nat -> Type -> Type where
    Empty : Vect 0 t
    Cons : t -> Vect n t -> Vect (S n) t
  ```
]

В данном случае тип `Vect n t` представляет собой односвязный список длины `n` из элементов типа `t`. Он зависит от значения своего первого аргумента --- натурального числа. Рассмотрим полную мономорфизацию по этому аргументу со значением 100. Для построения конструктора `Cons` типа `Vect_100` необходимо провести полную мономорфизацию всех его аргументов, включая тип `Vect 99 t`, т.е. построить тип `Vect_99`. Для его построения, в свою очередь, нужно построить `Vect_98` и т.д. В итоге будет сгенерировано 100 типов. Этот пример наглядно демонстрирует, что подстановка нетиповых аргументов зависимых типов в некоторых случаях нежелательна.

Также присутствие зависимых типов усложняет процесс унификамии конструкторов. В то время как в классическом GADT, все аргументы (и, как следствие, все подвыражения конструктора) являлись типами (или, в случае некоторых подвыражений, вариантами обобщённых типов), задача проверки их равенства была решаема в общем случае. Присутствие зависимых типов расширяет эту задачу до проверки потенциального равенства двух произвольных выражений и нахождения набора переменных, при котором они будут равны. Исходя из возможности присутствия ветвления, вызова функций (возможно, рекурсивных или взаимно рекурсивных), и локальных деклараций внутри этих выражений, был сделан вывод, что решение задачи унификации выражений в общем виде выходит за рамки ВКР.

=== Существующие подходы к зависимо-типизированной унификации.

Унификация типовых выражений является неотъемлемой частью выведения типов, а потому реализуется компиляторами зависимо-типизированных языков. Таким образом, один из потенциальных способов решить задачу унификации -- воспользоваться реализацией унификации выражений внутри компилятора Idris2. 

У этого подхода есть ряд существенных недостатков. Во-первых, внутреннее представление компилятора, на котором тот выполняет унификацию, значительно отличается от внутреннего представления, которое тот предоставляет метапрограммам. Для их использования потребовалось бы каким-то образом преобразовать внутреннее представление метапрограммы во внутреннее представление компилятора.  Во-вторых, множество внутренних механизмов компилятора Idris2 используют абстракции, недоступные для метапрограмм, такие как монада `IO`. В-третьих, даже если конвертациия внутренних представлений и использование внутренних методов компилятора были бы возможны, мономорфизатор и любой проект, его использующий, зависил бы от внутреннего API компилятора, т.е. для их сборки была бы необходима сборка компилятора.

Альтернативный подход -- реализовать один из имеющихся @abel_higher-order_2011 @Abel2018ExtensionsTM @pdt_twintypes алгоритмов унификации зависимых выражений. Его основной недостаток -- сложность и обобщённость таких алгоритмов. Эти алгоритмы расчитаны на решение задачи унификации выражений выраженных в абстрактной форме в наиболее общем случае. Для использования этих алгоритмов необходимо конвертировать внутреннее представление языка Idris2 в форму, для которой эти алгоритмы применимы, что включает в себя, помимо всего прочего, подстановку тел функций в места их вызова. В данный момент средствами мономорфизации невозможно получить тело функции по её имени.

Подход, выбранный в этой работе -- разработка и реализация намного более простого, узкоспециализированного алгоритма унификации зависимо-типизированных типовых выражений, который использует возможности интерфейса метапрограмм Idris2 и оперирует на внутреннем представлении, которое предоставляется этим интерфейсом.

== Обоснование ограничения по рекурсии

В связи со сложностью мономорфизации полиморфных типов было принято решение не обрабатывать типы, для полной мономорфизации которых необходима мономорфизация других типов. При мономорфизации таких типов полученный в итоге тип будет использовать полиморфные типы.

== Анализ практичности унификации типов выражений Idris2

Всего внутреннее представление языка Idris2 содержит 30 различных типов выражений. Для анализа практичности их унификации, они были разделены на 6 групп.

- Литералы --- Примитивные типы, их значения и тип типов. Унификация тривиальна, поскольку для любых двух таких выражений известно их равенство известно и не зависит от контекста.
- Переменные --- Унификация возможна и практична, если существует возможность проверять переменные, объявленные вне унифицированных выражений на равенство.
- Блоки с объявлением свободных переменных --- Сигнатуры функций, лямбда-функции и Pattern Matching. Их унификация проблематична тем, что их присутствие существенно усложняет идентификацию свободных переменных и хранение информации о требованиях к ним.
- Объявление переменной в блоке --- Поскольку такой тип выражения не создаёт новых свободных переменных, унификация свободна и практична.
- Применение функции --- Мономорфизация возможна для подмножества таких выражений. В частности, если применяемая функция -- обобщенный тип или конструктор, то унификация тривиальна. При применении настоящих функций унификация требует доступа к телу функции, который невозможен в контексте метапрограмм для Idris2.
- Метапеременные и служебные типы выражений --- не должны встречаться в унифицируемых выражениях, унификация невозможна.

== Заключение по первой главе

В данной главе рассмотрен процесс мономорфизации типов в языках функционального программирования и проблематика его реализации в рамках различных систем типов, включая зависимые типы. Описаны понятия ADT и GADT и проблематика мономорфизации последнего. Описана проблема унификации и трудности её реализации в контексте зависимых типов. Описаны существующие подходы к унификации зависимо-типизированных выражений и препятствия к их использованию в проекте. Обосновано ограничение по рекурсии типов. Проведен анализ практичности унификации типов выражений Idris2.

#chapter[Алгоритм мономорфизации]

== Входные данные

Алгоритм получает на вход целевой вариант типа и название выходного типа.

#figure(caption: "Пример")[
  ```idris
  -- Сигнатура типа Vect
  data Vect : Type -> Nat -> Type

  -- Вектор строк произвольной длины
  %runElab monomorphise (\l => Vect l String) "VectString"
  -- Вектор произвольного типа длины 10
  %runElab monomorphise (\t => Vect 10 t) "Vect10"
  ```
]

Также алгоритму доступна информация о типах, доступная при исполнении метапрограмм на Idris2.

== Процесс мономорфизации зависимых типов в контексте Idris2

В Главе 1 был сформулирован процесс мономорфизации для зависимо-типизированных GADT:
1. Подстановка аргументов, данных для мономорфизации, в тело типа. Составление набора аргументов типа. Составление целевого типа.
2. Обход конструкторов типа. Для каждого конструктора:
  1. Сбор именованных аргументов конструктора.
  2. Унификации типа, возвращаемого конструктором набору аргументов с целевым.
  3. Для конструкторов, которые могут создать искомый тип - подстановка аргументов, найденных в шаге 2.
3. Генерация имени сигнатуры мономорфного варианта типа.
4. Замена всех встречающихся в конструкторах вызовов типа с набором аргументов, для которого осуществляется мономорфизация, на вызов мономорфного варианта типа.
5. Генерация имен конструкторов и их подстановка.

Однако помимо непосредственно мономорфизации типа для поддержки деривации генераторов и будущей интеграции алгоритма с библиотекой DepTyCheck необходимо реализовать автоматическое выведение методов решаемого равенства, которые возвращают для двух равных значений типа доказательство их равенства и конвертацию из полиморфного типа в мономорфный и обратно.

== Проблема унификации типов и её решения

Как было описано в Главе 1, основным препятствием в реализации мономорфизации зависимых типов является проблема унификации -- определения для пары выражений со свободными переменными множества значений (и/или набора требований для) этих переменных, при которых выражения равны.

Процесс унификации логично разделить на три этапа: сбор информации о требованиях к свободным переменным, объединение этих требований и взаимная подстановка значений переменных.

В рамках первого этапа производится попарный рекурсивный обход выражения, результатом которого становится набор требований к свободным переменным и возможных противоречий в выражениях, делающих унификацию невозможной. При наличии таких противоречий процесс унификации завершается досрочно с выводом о невозможности унификации таких выражений. В противном случае происходит переход ко второму этапу унификации.

В рамках второго этапа производится дальнейшая обработка полученных требований -- поиск в них противоречий и их объединение. В результате этого этапа для каждой свободной переменной, к которой есть требования, становится известным единственное выражение, которому она равна. Однако в этих выражениях могут упоминаться другие переменные.

В рамках третьего этапа происходит взаимная подстановка значений выражений. Для этого строится граф зависимости переменных друг от друга. Далее переменные, не зависящие от других переменных, по очереди подставляются во все выражения, где они упоминаются. В результате такого процесса каждой свободной переменной, для которой имеются требования, сопоставляется выражение, в котором не упоминаются другие свободные переменные.

#let flowchart(..args) = {
  set par(leading: 0.65em)
  diagram(
    node-stroke: 1pt,
    node-shape: fletcher.shapes.rect,
    ..args,
  )
}
#let start-node = node.with(corner-radius: 2pt, extrude: (0, 3), outset: 3pt)
#let branch-node = node.with(shape: fletcher.shapes.diamond.with(fit: 0.7))
#let hackbr-node(pos, content, ..args) = node(
  pos,
  block(inset: (bottom: 1mm), spacing: 0em, align(center, content)),
  shape: fletcher.shapes.diamond,
  ..args,
)

#figure(caption: "Обобщённый алгоритм унификации")[
  #flowchart(
    start-node((0, 0), [Старт]),
    edge("-|>"),
    node((0, 1), [Сбор требований]),
    edge("-|>"),
    branch-node((0, 2), [Присутствуют \ невозможные \ требования?]),
    edge("l,d,d", "-|>", [Да]),
    start-node((-1, 4), [Унификация \ невозможна]),
    edge((0, 2), (0, 3), "-|>", [Нет]),
    node((0, 3), [Объединение требований]),
    edge("-|>"),
    hackbr-node((0, 4), [Найдены\ противоречия?]),
    edge("-|>", [Нет]),
    edge((0, 4), (-1, 4), "-|>", [Да]),
    start-node((1, 4), [Унификация\ успешна]),
  )
]

=== Унификация чистых типовых выражений

При отсутствии зависимых типов, проблема унификации решаема в общем виде, хотя и нетривиальна. Выражение, возвращающее тип, является в такой ситуации либо свободной переменной, либо обращением к типу по имени, либо вызовом обобщенного типа с несколькими аргументами, которые представляют собой другие типовые выражения.

#figure(caption: "Иллюстрация чисто типовых выражений")[
  ```idris
  -- Обращение к типу Nat по имени
  a : Nat
  -- Вызов обобщённого типа List c аргументом Nat
  b : List Nat
  -- Пример более сложного вызова обобщённого типа
  c : SortedMap (List String) (IO Int)
  ```
]

Равенство двух обращений к типу по имени эквивалентно равенству имён, а равенство двух вызовов обобщённого типа --- равенству обобщённого типа и всех переданных ему аргументов. Таким образом, не считая свободных переменный, два типовых выражения равны тогда и только тогда, когда они полностью соответствуют друг другу. В случае равенства двух свободных переменных или свободной переменной и другого выражения, унификатор записывает это в список требований.

#figure(caption: "Алгоритм поиска требований при отсутствии зависимых типов")[
  #flowchart(
    // debug: 3,
    start-node((0, 0), [Старт]),
    edge("-|>"),
    branch-node((0, 1), [Свободные\ переменные?]),
    edge("ll", "-|>", [Обе]),
    edge("rr", "-|>", [Одна], label-pos: 0.25),
    edge("d", "-|>", [Нет]),
    start-node((-2, 1), [Свободные \ переменные \ должны быть \ равны друг другу]),
    start-node((2, 1), [Свободная \ переменная \ должна быть\ равна значению]),
    branch-node((0, 2), [Типы\ выражения\ совпадают?]),
    edge((0,2),(2,2), "dd", "-|>", [Нет], label-pos: 0.1),
    edge("-|>", [Да]),
    hackbr-node((0, 3), [Тип \ выражения?]),
    edge((0, 3), (-2, 3), "-|>", [Вызов]),
    edge("d", "-|>", [Переменная]),
    node((-2, 3), [Собрать требования\ аргументов]),
    edge((-2, 3), (-2.7, 3), (-2.7, 0), (0, 0), "-|>"),
    branch-node((0, 4), [Равны между\ собой?]),
    edge("ll", "-|>", [Да]),
    edge("rr", "-|>", [Нет]),
    start-node((-2, 4), [Нет требований]),
    start-node((2, 4), [Противоречие]),
  )
]

После нахождения всех условий, начинается процесс их объединения. Он состоит из двух частей. В первую очередь, переменные группируются на основе равенства друг другу. Так как все условия, применимые к переменной, по определению применимы ко всем переменным, им равным, это единственный способ собрать все ограничения, которые действуют на каждую конкретную переменную.

Затем происходит поиск противоречий в этих условиях. Если на каждую переменную действует не более одного условия, то противоречий нет по определению. Иначе, необходимо для каждой пары условий равенства выражению, действующих на переменную, произвести поиск условий равенства её выражений. Затем необходимо добавить полученные условия о равенстве переменных друг другу к уже имеющимся и заменить имеющиеся условия о равенстве переменных выражениям на новые. Этот шаг повторяется, пока не будет найдено противоречие (в случае чего алгоритм унификации возвращает его), или пока его применение не перестанет изменять данные условия. В таком случае, полученный набор условий является финальным.

#figure(caption: "Алгоритм объединения требований при отсутствии зависимых типов")[
  #flowchart(
    // debug:3,
    start-node((0, 0), [Старт]),
    edge("-|>"),
    node((0, 1), [Сгруппировать требования\ по переменным]),
    edge("-|>"),
    branch-node((0, 2), [Есть переменные\ с $>1$ требований?]),
    edge("dd", "-|>", [Нет]),
    edge("l", "-|>", [Да]),
    node((-1, 2), [Вывести новые\ требования\ из равенства]),
    edge("d", "-|>"),
    branch-node((-1, 3), [Появились\ противоречия?]),
    edge("l,uu,rr", "-|>", [Нет], label-pos: 0.15),
    edge("d", "-|>", [Да]),
    start-node((-1, 4), [Унификация невозможна]),
    start-node((0, 4), [Получены\ финальные\ требования]),
  )
]

Получив финальный набор требований, можно приступить к выведению значений переменных. Для этого строится граф зависимости переменных (вернее, граф зависимости множеств взаимно равных переменных). В случае наличия циклов в графе, унификация невозможна, и алгоритм завершается. В случае отсутствия циклов, можно вычислить значения переменных.

Это происходит в рамках итеративного алгоритма. На каждой итерации, находятся вершины графа, которые не зависят ни от одной другой вершины. Их значения подставляются в выражения всех вершин, которые от них зависят, и зависимости удаляются. Алгоритм завершается, когда ни одна вершина не зависит от другой.

Получившиеся в результате подстановки выражения -- финальные значений переменных, которые возвращаются в результате унификации.

=== Унификация зависимых типов
Присутствие зависимых типов расширяет множество классов выражений, которые могут встречаться при унификации. Назовём любое выражение, использующее в качестве своих аргументов значения зависимым выражением. Такие выражения включают в себя не только вызов обобщённых типов с параметрами-значениями, но и ветвление, вызовы функций, локальные объявления, и прочие выражения, для которых суждение о результате до их выполнения трудно или невозможно.

Более того, при отсутствии зависимых типов свободная переменная могла иметь только одно корректное значение (или, в случае зависимости от другой, неопределенной свободной переменной, заменялась в конструкторе на одно выражение). Зависимые типы же позволяют тривиально привести пример, при котором это не так.

#figure(caption: "Пример зависимого типа, для которого унификация не решается однозначно")[
  ```idris
  data ExampleType : Nat -> Nat -> Type where
    ExampleCon : (x : Nat) -> ExampleType x (x `mod` 2)

  ex1 : ExampleType 5 1
  ex1 = ExampleCon 5

  ex2 : ExampleType 20 0
  ex2 = ExampleCon 20

  -- Как создать значение (ExampleType x 1)?
  -- Конструктор существует только при x % 2 == 1!
  ```
]

Таким образом, при появлении зависимых выражений, типичная реализация унификации и обработки её решений перестаёт работать.
=== Фординг

Тем не менее, благодаря возможности выражать произвольные логические утверждения через зависимые типы, существует способ частично обойти проблему унификации зависимых выражений. Он заключается в переносе доказательства возможности или невозможности унификации с момента мономорфизации типа на момент использования конкретного мономорфного конструктора путём включения типа, обозначающего искомое равенство в качестве аргумента этого конструктора.

Поскольку в интуиционистской логике построение равноценно доказательству, такой конструктор можно будет использовать тогда и только тогда, когда для всех условий построения предоставлено доказательство.

#figure(caption: "Пример мономорфизации зависимого типа с фордингом и его использования")[
  ```idris
  data MVect : Nat -> Type -> Type where
    N : MVect 0 t
    MCons : t -> MVect n t -> MVect (S n) t

  data MVect1 : Type -> Type where
    MCons1 : t -> MVect n t -> (S n) = 1 => MVect1 t

  data MVect0 : Type -> Type where
    N0 : MVect0 t
    MCons0 : t -> MVect n t -> (S n) = 0 => MVect0 t

  to1 : MVect 1 t -> MVect1 t
  to1 (MCons x xs) = MCons1 x xs @{Refl}

  from1 : MVect1 t -> MVect 1 t
  from1 (MCons1 x xs @{pf}) = rewrite sym pf in MCons x xs

  to0 : MVect 0 t -> MVect0 t
  to0 N = N0
  to0 (S n) impossible

  from0 : MVect0 t -> MVect 0 t
  from0 N0 = N
  from0 (MCons0 x xs @{pf}) = rewrite sym pf in MCons x xs
  ```
]

Такой подход обладает своими недостатками. В первую очередь, фординг усложняет использование сгенерированных мономорфных типов, требуя доказательств. Во-вторых, с помощью фординга нельзя сгенерировать инфраструктуру для типов, которые содержат выражения, возвращающего разные обобщенные типы (а не просто разные его версии) в зависимости от входных данных. В-третьих, фординг может приводить к генерации неоптимальных мономорфных типов (лишние условия и т.д.). В-четвертых, фординг может приводить к появлению параметров из сигнатуры типа в конструкторе, чего не случается при его отсутствии.

Несмотря на это, фординг остаётся единственным способом корректно мономорфизировать некоторые зависимые GADT, т.к. задача унификации зависимых выражений в общем случае нерешаема. Также фординг позволяет компенсировать невозможность получить содержимое тела функции с помощью средств метапрограммирования Idris2.
== Заключение по второй главе

В данной главе описан алгоритм мономорфизации зависимых типов. Разобраны в деталях задача унификации типовых выражений и её решение. Описана процедура фординга условий, применяемых к нетиповым подвыражениям, её преимущества и недостатки.

#chapter[Реализация и тестирование алгоритма]

== Средства реализации

Язык Idris2 обладает широким набором возможностей, связанных с метапрограммированием. Основным интерфейсом, через который оно в нём осуществляется, является монада `Elab`. Как и многие другие монады в языках с функциональным программированием, `Elab` выражает операцию с побочными эффектами -- получением информации об объявленных типах и переменных и о текущем пространстве имён, объявлении новых переменных и toplevel-деклараций, и записи текста в логи компилятора.

Функции, возвращающие в качестве результата монаду `Elab`, называются скриптами элаборатора. Для их применения используется директива компилятора `%runElab`. При её обработке, компилятор приостанавливает работу, вычисляет значение монады `Elab`, переданной в директиву, и выполняет описанную ей операцию. Директива `%runElab` может быть использована как в виде toplevel-декларации в случае, где вычисление не возвращает результата, так и в виде значения внутри выражения, где результат вычисления подставляется на место директивы.

#figure(caption: "Пример скрипта элаборатора и его использования")[
  ```idris
  -- Выводит сообщение в лог
  basicELS' : Elab ()
  basicELS' = logMsg "basic" 0 "Hello world!"

  -- Проверяет, существует ли переменная с данным названием
  basicELS : Name -> Elab Bool
  basicELS n = do
    -- Получить информацию о всех переменных с таким названием
    ts <- getType n
    -- Записать сообщение в лог
    logMsg "basicELS" 0 "Hello World again!"
    -- Проверить, пустой ли список, вернуть результат
    pure $ (length ts) > 0

  -- Вызов в виде toplevel-декларации
  %runElab basicELS'

  -- Вызов как часть выражения
  elsTest : Bool
  elsTest = %runElab basicELS `{test}
  ```
]

Монада `Elab` и другие типы и функции, связанные с метапрограммированием, являются частью стандартной библиотеки Idris2 и располагаются в пространстве имён `Language.Reflection`.

Однако стандартная библиотека Idris2 предоставляет только базовые средства метапрограммирования. Одна из областей, требующих абстракций, реализованных на основе стандартной библиотеки -- сбор информации о сигнатурах символов, параметрах и конструкторах типов. Для решения этих задач используется библиотека `elab-util`, содержащая различные вспомогательные функции для метапрограммирования.

== Реализованный функционал и особенности реализации

Описанные алгоритмы мономорфизации и унификации типов были реализованы в виде метапрограмм (скриптов элаборатора) на языке Idris2 и располагаются в модулях `Language.Reflection.Monomorphise` и `Language.Reflection.Unify` соответственно.

#let groupat((x, y), name, label: (), ..labels) = {
  let mv(x) = x.value
  let dotpos(x) = x.value.pos.raw
  let positions = labels.pos().map(dotpos)
  let snd(x) = x.at(1)
  let gtop = calc.min(..positions.map(snd))
  let labnode = node((x, gtop - 0.8), name, stroke: none)
  (..labels.pos(), labnode, node(enclose: ((x, gtop - 0.8), ..positions), name: label))
}

#figure(caption: [Архитектура программы])[
  #flowchart(
    // debug: 3,
    spacing: (10mm, 7mm),
    groupat(
      (-0.5, -0.8),
      [Мономорфизация типов],
      label: <monogroup>,
      node((-0.9, -3), [Сбор информации\ о типах], name: <monoty>),
      node((-0.9, -2), [Построение задачи\ унификации]),
      node((-0.1, -3), [Генерация кода]),
    ),
    groupat(
      (-1, -0.8),
      [Унификация выражений],
      label: <unigroup>,
      node((-1, 0), [Сбор требований\ к переменным], name: <collecteq>),
      node((-1, 1), [Разрешение зависимостей\ между переменными], name: <depgraph>),
    ),
    groupat(
      (0, -0.8),
      [Подстановка переменных],
      label: <subgroup>,
      node((0, 0), [Сбор информации\ о затенении], name: <iozat>),
      node((0, 1), [Сбор информации\ о квотировании], name: <ioquot>),
    ),
    edge(<unigroup>, <subgroup>, "-|>"),
    edge(<monogroup>, <unigroup>, "-|>"),
    edge(<monogroup>, <subgroup>, "-|>"),
  )
]
=== Подстановка переменных

Поскольку подстановка значения переменной в выражении является неотъемлемой частью унификации, в первую очередь был реализован именно алгоритм подстановки значений переменной в выражение.

Поскольку выражения во внутреннем представлении языка Idris2 представляют собой деревья из значений взаимно рекурсивных типов, множество сложных операций над ними реализуются в виде рекурсивного обхода. Стандартная библиотека Idris2 предоставляет несколько функций, позволяющих применять трансформации различной сложности к внутреннему представлению выражений. Самая мощная из них -- `mapATTImp'` -- позволяет применить к каждой вершине внутреннего представления монадическую трансформацию, способную предоставлять контекст и изменять результаты трансформациям её потомков. Этот интерфейс предоставляет собой монадический аналог Visitor-паттерна.

При подстановке значения переменной недостаточно найти все обращения к переменной по имени и подставить в них значения: необходимо знать, указывает ли имя в определённом контексте на искомую переменную. Такого может не происходить в двух случаях: при квотировании и затенении.

Квотирование -- возможность использовать определённым образом отмеченные выражения языка Idris2 в качестве литералов их внутреннего представления. Внутри квотированных выражений имена не указывают ни на какие переменные, за исключением выражений, находящихся внутри оператора подстановки.

#figure(caption: [Примеры квотирования])[
  ```idris
  -- Квотирование выражения
  q1 : TTImp
  q1 = `(List Nat)

  -- Квотирование деклараций
  q2 : List Decl
  q2 = `[
    a : Nat -> Nat
    a x = x - 6
  ]
  
  -- Выход из квотирования / оператор подстановки
  q3 : TTImp
  q3 = `(SortedSet String ~(q1)) 
  -- == `(SortedSet String (ListNat))
  ```
]

Затенение -- свойство языка, где при объявлении среди предков выражения нескольких переменных с одинаковым именем приоритет отдаётся объявленной глубже переменной.

#figure(caption: [Пример затенения])[
  ```idris
  x : Nat
  x = let a = 10 in (let a = 5 in (a + 1))
  -- x == 6
  ```
]

Для простоты переиспользования сбор информации о квотировании и затенении был вынесен в отдельные функции, а информация об объявленных квотировании и затенении -- в отдельные трансформаторы монад, основанные на монаде `Reader`.

Итого, для реализации подстановки переменных использовался монадический Visitor-паттерн в сочетании с двумя трансформаторами монад, собиравшими в процессе обхода внутреннего представления информацию об объявленных переменных и квотировании.

=== Унификация типовых выражений

Реализация унификации в целом соответствует алгоритму, описанному во второй главе. Для сбора условий используется взаимно рекурсивный спуск по внутреннему представлению выражений. При спуске сохраняется промежуточное состояние унификации -- хранятся множества переменных, равных друг другу, выражения, которым они равны, и список равенств, подлежащих фордингу.

Фазы сбора и разрешения требований ради простоты реализации и более быстрого обнаружения противоречий были объединены в один взаимно рекурсивный процесс. Как только один и тот же набор переменных оказывается равен двум подвыражениям, происходит рекурсивный вызов функции унификации для этих подвыражений, и условия их равенства добавляются к имеющимся.

После вычисления финального результата унификации, происходит подстановка этих результатов в равенства, подлежащие фордингу.

=== Мономорфизация типа

Операция мономорфизации принимает на вход два параметра -- название, которое будет иметь мономорфный тип, и задание мономорфизации. Последнее представляет собой либо вызов некоторого полиморфного типа с набором аргументов, либо лямбда-функцию, которая такой вызов возвращает.

// #figure(caption: [Сигнатура и использование функции мономорфизации])[
//   ```idris
//   -- Полностью мономорфизировать тип List с аргументом String
//   %runElab monomorphise (List String) "ListString"
//
//   -- Частично мономорфизировать тип SortedMap
//   %runElab monomorphise (\t => SortedMap Nat t) "SortedMapNat"
//   ```
// ]

Таким образом, из задания мономорфизации всегда можно вывести список аргументов для мономорфного типа при их наличии, и выражение-вызов полиморфного типа, которому соответствует мономорфный тип.

Далее производится сбор информации о конструкторах с помощью инструментов библиотеки `elab-util`. Для каждого конструктора проводится унификация. Унифицируется вариант типа, возвращаемый конструктором (параметрами которого являются параметры конструктора) и полное выражение-вызов зависимого типа, полученное из задачи мономорфизации (параметрами которого являются параметры, полученные из задачи мономорфизации).

В случае провала унификации, конструктор опускается из мономорфного типа. В случае успеха, на его основе создаётся соответствующий конструктор мономорфного типа. На основе полученных в результате унификации условий и значений переменных, из конструктора опускаются аргументы, значения которых известны, а их вызовы в сигнатуре возвращаемого типа заменяются на эти значения. Также к аргументам конструктора добавляются доказательства равенств, подлежащих фордингу. Получившиеся таким образом конструкторы снова собираются в мономорфный тип, который является основным результатом работы алгоритма.

=== Выведение реализаций интерфейсов для мономорфного типа

Следующий шаг генерации кода -- выведение функций конвертирования. Выводятся их сигнатуры вида "Для любого значения набора параметров типа существует функция конвертации значений такого типа". При реализации функции каждому конструктору мономорфного типа сопоставляется конструктор полиморфного типа.

#figure(caption: "Пример сгенерированной функции конвертирования")[
  ```idris
  castM2P : (n : Nat) => VectNat n -> Vect n Nat
  castM2P [] = []
  castM2P (x::xs) = (x::xs)

  %hint
  castImpl : (n : Nat) => Cast (Vect n Nat) (VectNat n)
  castImpl = MkCast castM2p
  ```
]

На основании функции конвертирования становится возможным реализация для мономорфного типа ряда интерфейсов, реализованных для полиморфного типа. Каждая такая реализация принимает в качестве Implicit-параметров все параметры мономорфного типа, а также реализацию интерфейса для полиморфного типа. Реализация методов интерфейса для мономорфного типа сводится к конвертированию его значений в значения полиморфного типа и применению методов интерфейса для полиморфного типа к ним.

#figure(caption: "Пример реализации интерфейса Show")[
  ```idris
  showImpl : (n : Nat) => Show (Vect n Nat) => Show VectNat n
  showImpl = MkShow (show . cast) (\_, x => show $ cast x)
  ```
]

== Тестирование алгоритма мономорфизации

Предполагается тестирование алгоритма двумя способами: Unit-тестированием и End-to-end тестированием.

В случае Unit-тестирования предполагается тестирование компонентов алгоритма, не являющихся метарпограммами в своей на корректность их отдельной работы. В данный момент алгоритм подстановки переменной в выражении покрыт набором unit-тестов на предмет его работоспособности и семантической корректности. Unit-тесты реализованы с помощью порта библиотеки Property-based тестирования `hedgehog` на язык программирования Idris2.

Однако для компонент проекта, являющихся метапрограммами, классическое unit-тестирование невозможно. Скрипты элаборатора работают во время компиляции, и ошибки в них приводят к ошибкам компиляции. Соответственно, невозможно в рамках одной программы протестировать несколько метапрограмм на корректность. 

Для тестирования их работоспособности используется end-to-end тестирование. Каждый отдельный тест представляет собой программу на языке Idris2, для которой проверяются успешные компиляция и выполнение программы. Такой механизм поддерживается стандартной библиотекой Idris2 (в рамках модуля `Testing.Golden`) и используется для тестирования компилятора Idris2.

== Дальнейшее развитие

Возможные дальнейшие направления развития проекта включают:

+ Реализацию поддержки унификации выражений, объявляющих новые свободные переменные.
+ Частичную или полную реализацию поддержки мономорфизации рекурсивных типов.
+ Автоматическое выведение интерфейса решаемого равенства мономорфных типов при наличии его реализации для полиморфных. 
+ Интеграцию мономорфизатора в библиотеку DepTyCheck.
+ Использование автоматических инструментов тестирования для валидации базовых требований к алгоритмам мономорфизации и унификации.

== Заключение по третьей главе

В данной главе описаны средства и процесс реализации и тестирования алгоритма, приведены особенности реализации, описаны возможности по дальнейшему развитию проекта.

#heading(level: 1, numbering: none)[ЗАКЛЮЧЕНИЕ]
В результате выполнения выпускной квалификационной работы был разработан алгоритм мономорфизации практичного подмножества зависимых GADT и создана реализация этого алгоритма на языке Idris2 в виде метапрограммы. Полученные результаты являются важным шагом в процессе расширения множества полиморфных типов, поддерживаемых библиотекой DepTyCheck.

Были выполнены все поставленные задачи:
1. Ознакомиться с существующими алгоритмами мономорфизации типов
2. Выделить среди множества нерекурсивных зависимых типов классы типов, для которых мономорфизация возможна и практична
3. Разработать алгоритм мономорфизации для этих типов
4. Реализовать этот алгоритм в виде метапрограммы для языка Idris2
5. Произвести тестирование алгоритма

#bib-page("sources.bib")
