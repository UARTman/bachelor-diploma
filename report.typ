#import "report-template.typ": *
#import "@preview/fletcher:0.5.7" as fletcher: diagram, node, edge

#import "@preview/codly:1.3.0": *
#import "@preview/codly-languages:0.1.1": *
#show: codly-init.with()

#show: idris-setup
#show: gost-732-setup

#page(margin: auto, numbering: none)[
  #set par(justify: false, first-line-indent: 0pt, leading: 0.65em, spacing: 1.2em)
  #set align(center)
  #upper[
    *
    Правительство Российской Федерации \
    Федеральное государственное автономное \
    образовательное учреждение высшего образования \
    «Национальный исследовательский университет \ «Высшая школа экономики»
    *
  ]



  Факультет компьютерных наук \
  Образовательная программа бакалавриата «Программная инженерия»

  \

  #align(left)[
    УДК 004.43
  ]

  \

  #columns(2)[
    СОГЛАСОВАНО \
    Научный руководитель, \
    профессор БК\
    «Системное программирование»\
    ФКН НИУ ВШЭ, \
    Доктор физико-математических наук \
    #underline[#"                        "] А.К. Петренко \
    "#box[#underline[#"        "]]" #underline[#"                   "] 2025 г.


    #colbreak()
    УТВЕРЖДЕНО \
    Академический руководитель \
    образовательной программы \
    "Программная инженерия", \
    старший преподаватель \
    департамента программной инженерии \
    #underline[#"                        "] Н.А. Павлочев \
    "#box[#underline[#"        "]]" #underline[#"                   "] 2025 г.
  ]

  \


  *Выпускная квалификационная работа* \
  (проектно-исследовательская)

  на тему: *"Разработка алгоритма мономорфизации нерекурсивных структур данных с зависимыми типами и его программная реализация"*

  по направлению подготовки 09.03.04 "Программная инженерия"

  \

  #align(right)[
    #block()[
      #set align(center)
      ВЫПОЛНИЛ \
      Студент группы БПИ211 \
      образовательной программы \
      09.03.04 «Программная инженерия» \
      Гусев Антон Алексеевич \
      #text(size: 9pt)[(инициалы, фамилия)\ ]
      #underline[#"                                          "] \
      #text(size: 9pt)[(подпись, дата)] \
    ]
  ]

  \ \ \ \ \

  #align(center)[Москва 2024]
]

#section("РЕФЕРАТ")[
  Параметрический полиморфизм в языках функционального программирования с зависимыми типами в большинстве случаев осуществляется путём стирания типов. При этом существуют библиотеки на языках с зависимыми типами, неспособные работать с полиморфными типами. При использовании таких библиотек с большинством типов-контейнеров, программисту необходимо вручную производить мономорфизацию и конвертацию этих типов. Автоматизация этого процесса позволит значительно сократить количество повторяющегося кода и облегчит переиспользование кода.

  Отчёт описывает процесс мономорфизации типов, проблематику его реализации для обобщённых алгебраических типов и зависимых типов, и процесс его реализации и тестирования в качестве метапрограммы для языка Idris2.

  Данная работа состоит из #n_pages страниц, #n_chapters глав, #n_drawings рисунка, #n_listings листингов. Использовано #n_sources источников.

  *Ключевые слова*: Функциональное программирование, теория типов, зависимые типы, Idris, мономорфизация, специализация типов, унификация, параметрический полиморфизм.
]

#toplevel-heading[ABSTRACT]

  Functional languages achieve parametric polymorphism largely by way of type erasure. However, there exist libraries in dependently-typed languages that are unable to process polymorphic types. In order to use such libraries with most standard container types, the programmer must monomorphise the types and implement two-way conversion by hand. Automating this process will allow for drastic reduction in code repetition and make code reuse easier.

  The paper describes the process of type monomorphisation, issues surrounding its implementation for generic algebraic data types and dependent types, as well as the process for implementing and testing it as an Idris2 metaprogram.

  The paper contains #n_pages pages, #n_chapters chapters, #n_drawings figures, #n_listings listings. #n_sources sources are used.

  *Keywords*: Functional programming, type theory, dependent types, Idris, monomorphisation, type specialisation, unification, parametric polymorphism.

#outline-page

#toplevel-heading[ТЕРМИНЫ И ОПРЕДЕЛЕНИЯ]

*Параметрический полиморфизм* -- возможность обработки нескольких типов входных данных одним и тем же фрагментом кода.

// *Обобщённые типы* -- типы, которые принимают

*Зависимые типы* -- типы, которые зависят от значений. Такие типы позволяют кодировать собой инварианты их значений и выражать логические утверждения. Из-за этого свойства, зависимые типы используются в некоторых интерактивных решателях теорем и функциональных языках программирования.

#toplevel-heading[ВВЕДЕНИЕ]

Во многих статически типизированных языках программирования имеется возможность обработки значений данных нескольких типов одним и тем же кодом на основе общих свойств и семантики этих типов данных -- параметрический полиморфизм. Ему противопоставляется ad-hoc полиморфизм, в котором обработка данных разных типов может иметь различную логику и семантику. Например, C++ включает в себя обе парадигмы: перегрузка функций и операторов, как и классические шаблоны, представляет собой ad-hoc полиморфизм, в то время как ограничения (constraint) и концепты (concept) представляют собой попытку формализовать ad-hoc полиморфизм шаблонов в более параметрическую форму.

Типы и функции, допускающие параметрический полиморфизм, называются обобщёнными типами/функциями (generics).

Существуют два подхода к реализации параметрического полиморфизма -- стирание типов и мономорфизация @morrison1991ad @viroli2000parametric.

При стирании типов большинство значений оборачиваются в универсальную структуру, которая позволяет проверять наличие их полей и методов и получать к ним доступ во время исполнения программы. Это позволяет коду, полученному в результате компиляции, принимать на вход такие структуры вместо конкретных типов. Этот подход используется в высокоуровневых языках, например, Java @viroli2000parametric.

При мономорфизации каждый вариант полиморфного типа рассматривается как отдельный тип данных, а каждый вариант полиморфной функции -- как отдельная функция. Для каждой такой функции и для каждого метода каждого полиморфного типа генерируется отдельный код. Этот подход используется в низкоуровневых языках, например Ada и Rust.

Эти два подхода не всегда взаимоисключающие. В некоторых языках, например, Swift @swift_generics или Haskell, ограниченная мономорфизация функций применяется вместе со стиранием типов.

К таким языкам относится и язык функционального программирования с зависимыми типами Idris2. По умолчанию компилятор Idris2 генерирует промежуточный код на динамически-типизированном языке Scheme @idris2_compiling2execs.

Одна из областей применения зависимых типов -- автоматическая генерация значений сложных типов данных, например, различных файловых форматов или семантически корректных программ. Зависимые типы позволяют включить в структуры данных описание инвариантов, которым они подчиняются, и, поскольку в интуиционистской логике @Dalen2008IntuitionisticL построение равноценно доказательству, любое значение такой структуры данных будет подчиняться этим инвариантам. Такой функционал входит в состав библиотек для property-based тестирования, таких как QuickChick (для языка Coq) @paraskevopoulou2022computing и DepTyCheck (для языка Idris).

Некоторые из них, например, DepTyCheck @derivation_task, в настоящий момент не поддерживают генерацию значений полиморфных типов. При их использовании пользователю приходится вручную реализовывать мономорфизированные варианты таких типов и все необходимые ему методы, действующие над ними. Это приводит к повторению кода, а также затрудняет поддержку кодовой базы и вынесение абстракций в отдельные библиотеки.

Алгоритм мономорфизации зависимых типов позволит реализовать в этих библиотеках поддержку части полиморфных типов без изменения деталей реализации или API.

Цель работы -- Разработка алгоритма мономорфизации, поддерживающего практичное подмножество нерекурсивных зависимых типов.

Задачи работы:
1. Ознакомиться с существующими алгоритмами мономорфизации типов
2. Выделить среди множества нерекурсивных зависимых типов классы типов, для которых мономорфизация возможна и практична
3. Разработать алгоритм мономорфизации для этих типов
4. Реализовать этот алгоритм в виде метапрограммы для языка Idris2
5. Произвести его тестирование

#chapter[ОБЗОР ЗАДАЧИ МОНОМОРФИЗАЦИИ]

== Представление типов в языках программирования

В основе систем типов языков функционального программирования лежит понятие алгебраического типа данных (Algebraic Data Type, ADT). В этой модели тип задаётся набором аргументов, каждый из которых является типом, и набором конструкторов -- функций, возвращающих значение типа.

#figure(caption: "Пример ADT в Idris")[
  ```idris
  data List a = Empty | Cons a (List a)
  ```
]

Например, тип `List` описывает односвязный список. Конструктор `Empty` обозначает конец списка, а конструктор `Cons` -- его звено.

=== GADT

Обобщённые алгебраические типы данных (Generic Algebraic Data Type, GADT) -- расширение ADT, которое позволяет конструкторам возвращать не только тип в том виде, в котором он задан, но и с любым другим набором аргументов. Язык Idris2 использует GADT в качестве основы своей системы типов.

#figure(caption: "Пример GADT в Idris")[
  ```idris
  data AList : Type -> Type where
    EmptyN : AList Nat
    EmptyS : AList String
    ConsN : Nat -> AList String -> AList Nat
    ConsS : String -> AList Nat -> AList String
  ```
]

Такая абстракция позволяет накладывать на значения объявленных типов более сложные инварианты. К примеру, продемонстрированный тип `AList` описывает список, в котором чередуются числа и строки. Описать такой тип в виде ADT невозможно.

== Задача мономорфизации ADT без зависимых типов

Задачу мономорфизации простого ADT можно разделить на два этапа. Сначала происходит подстановка аргументов типа в тела конструкторов. Затем в телах конструкторов находятся все места вызова исходного типа и заменяются вызовом его мономорфного варианта.

#figure(caption: "Пример мономорфизированного ADT")[
  ```idris
  data List_String = Empty_String 
                   | Cons_String String (List_String)
  data List_Nat = Empty_Nat | Cons_Nat Nat (List_Nat)
  ```
]

GADT существенно усложняют задачу мономорфизации. Во-первых, каждый конструктор может содержать свои аргументы, не связанные с аргументами типа. Во-вторых, конструкторы GADT создают варианты типа с различными наборами аргументов, и следовательно существуют наборы аргументов, для которых не все конструкторы смогут создать инстанцию типа.

При мономорфизации GADT, простая подстановка переменных заменяется более сложным процессом. Для типа и каждого и его конструкторов определяются объявленные в них аргументы и возвращаемый тип. Далее, для каждого конструктора происходит процесс унификации -- поиска набора аргументов типа и конструктора, при котором возвращаемые типы равны.

Конструкторы, для которых такого набора нет, опускаются, так как они не могут построить вариант типа с искомыми аргументами, и, как следствие, его мономорфный вариант. Конструкторы, для которых такой набор есть, включаются в мономорфный вариант GADT с подставленными аргументами.

#figure(caption: "Пример мономорфизированного GADT")[
  ```idris
  data AList_String : Type where
    EmptyS_String : AList_String
    ConsS_String : String -> AList_Nat -> AList_String
  data AList_Nat : Type where
    EmptyN_Nat : AList_Nat
    ConsN_Nat : Nat -> AList_String -> AList_Nat
  ```
]

== Существующие исследования в области мономорфизации зависимых типов

Многие языки с зависимыми типами поддерживают опциональную или частичную мономорфизацию функций, но проблема мономорфизации типов в зависимо-типизированных языках практически не рассматривалась. В единственной известной мне работе @tanaka2018safe она встречалась как один шаг в процедуре генерации кода на низкоуровневых языках из высокоуровневого представления и не поддерживала мономорфизацию зависимых типов.

== Специфика мономорфизации зависимых типов

Мономорфизация GADT ещё сильнее усложняется добавлением зависимых типов. Зависимый тип может принимать в качестве аргумента не только другие типы, но и любые значения, включая известные только во время выполнения программы. Рассмотрим пример зависимого типа:

#figure(caption: "Пример зависимого типа в Idris")[
  ```idris
  data Vect : Nat -> Type -> Type where
    Empty : Vect 0 t
    Cons : t -> Vect n t -> Vect (S n) t
  ```
]

В данном случае тип `Vect n t` представляет собой односвязный список длины `n` из элементов типа `t`. Он зависит от своего первого аргумента - натурального числа. Рассмотрим мономорфизацию по этому аргументу со значением 100. Для построения конструктора `Cons_100` типа `Vect_100`, необходимо построить тип `Vect_99`. Для его построения нужно построить `Vect_98`. В итоге будет сгенерировано 100 типов. Этот пример наглядно демонстрирует, что подстановка нетиповых аргументов зависимых типов в некоторых случаях нежелательна.

Также присутствие зависимых типов усложняет процесс унификации конструкторов. В то время как в классическом GADT, все аргументы (и, как следствие, все подвыражения конструктора) являлись типами (или, в случае некоторых подвыражений, инстанциями обобщённых типов), задача проверки их равенства была решаема в общем случае. Присутствие зависимых типов расширяет эту задачу до проверки потенциального равенства двух произвольных выражений и нахождения набора переменных, при котором они будут равны. Исходя из возможности присутствия ветвления, вызова функций (возможно, рекурсивных или взаимно рекурсивных), и локальных деклараций внутри этих выражений, был сделан вывод, что решение задачи унификации выражений в общем виде выходит за рамки задачи ВКР.

== Существующие подходы к зависимо-типизированной унификации.

Унификация типовых выражений является неотъемлемой частью выведения типов, а потому реализуется компиляторами зависимо-типизированных языков. Таким образом, один из потенциальных способов решить задачу унификации -- воспользоваться реализацией унификации выражений внутри компилятора Idris2. У этого подхода есть ряд существенных недостатков. Во-первых, внутреннее представление компилятора, на котором тот выполняет унификацию, значительно отличается от внутреннего представления, которое тот предоставляет метапрограммам. Во-вторых, множество внутренних механизмов компилятора Idris2 используют абстракции, недоступные для метапрограмм, такие как монада `IO`. В-третьих, даже если конвертациия внутренних представлений и использование внутренних методов компилятора были бы возможны, мономорфизатор и любой проект, его использующий, зависил бы от внутреннего API компилятора, т.е. для их сборки была бы необходима сборка компилятора.

Альтернативный подход -- реализовать один из имеющихся @abel_higher-order_2011 @Abel2018ExtensionsTM @pdt_twintypes алгоритмов унификации зависимых выражений. Его основной недостаток -- сложность таких алгоритмов. Эти алгоритмы расчитаны на решение задачи унификации выражений выраженных в абстрактной форме в наиболее общем случае и не предполагают доступа к возможностям, которые компилятор Idris2 предоставляет метапрограммам.

Подход, выбранный в этой работе -- разработка и реализация намного более простого, узкоспециализированного алгоритма унификации зависимо-типизированных типовых выражений, который использует возможности интерфейса метапрограмм Idris2 и оперирует на внутреннем представлении, которое предоставляется этим интерфейсом.

== Обоснование ограничения по рекурсии

В связи со сложностью мономорфизации полиморфных типов было принято решение не обрабатывать типы, для полной мономорфизации которых необходима мономорфизация других типов. При мономорфизации таких типов полученный в итоге тип будет использовать полиморфные типы.

== Заключение по первой главе

В данной главе рассмотрен процесс мономорфизации типов и проблематика его реализации в рамках различных систем типов, включая зависимые типы. Описаны понятия ADT и GADT и проблематика мономорфизации последнего. Описана проблема унификации и трудности её реализации в контексте зависимых типов. Описаны существующие подходы к унификации зависимо-типизированных выражений и препятствия к их использованию в проекте. Обосновано ограничение по рекурсии.

#chapter[Алгоритм мономорфизации]

== Входные данные

Алгоритм получает на вход целевой вариант типа и название выходного типа.

#figure(caption: "Пример")[
  ```idris
  -- Сигнатура типа Vect
  data Vect : Type -> Nat -> Type

  -- Вектор строк произвольной длины
  %runElab monomorphise (\l => Vect l String) "VectString"
  -- Вектор произвольного типа длины 10
  %runElab monomorphise (\t => Vect 10 t) "Vect10"
  ```
]

Также алгоритму доступна информация о типах, доступная при исполнении метапрограмм на Idris2.

== Процесс мономорфизации зависимых типов в контексте Idris2

В Главе 1 был сформулирован процесс мономорфизации для зависимо-типизированных GADT:
1. Подстановка аргументов, данных для мономорфизации, в тело типа. Составление набора аргументов типа. Составление целевого типа.
2. Обход конструкторов типа. Для каждого конструктора:
  1. Сбор именованных аргументов конструктора.
  2. Унификации типа, возвращаемого конструктором набору аргументов с целевым.
  3. Для конструкторов, которые могут создать искомый тип - подстановка аргументов, найденных в шаге 2.
3. Генерация имени сигнатуры мономорфного варианта типа.
4. Замена всех встречающихся в конструкторах вызовов типа с набором аргументов, для которого осуществляется мономорфизация, на вызов мономорфного варианта типа.
5. Генерация имен конструкторов и их подстановка.

Однако помимо непосредственно мономорфизации типа для поддержки деривации генераторов и будущей интеграции алгоритма с библиотекой DepTyCheck необходимо реализовать автоматическое выведение методов решаемого равенства, которые возвращают для двух равных значений типа доказательство их равенства и конвертацию из полиморфного типа в мономорфный и обратно.

== Проблема унификации типов и её решения

Как было описано в Главе 1, основным препятствием в реализации мономорфизации зависимых типов является проблема унификации -- определения для пары выражений со свободными переменными множества значений (и/или набора требований для) этих переменных, при которых выражения равны.

Процесс унификации логично разделить на два этапа: сбор информации о требованиях к свободным переменным и объединение этих требований в финальную форму.

В рамках первого этапа производится попарный рекурсивный обход выражения, результатом которого становится набор требований к свободным переменным и возможных противоречий в выражениях, делающих унификацию невозможной. При наличии таких противоречий процесс унификации завершается досрочно с выводом о невозможности унификации таких выражений. В противном случае происходит переход ко второму этапу унификации.

В рамках второго этапа производится дальнейшая обработка полученных требований -- поиск в них противоречий и их сокращение в финальную форму.

#let flowchart(..args) = {
  set par(leading: 0.65em)
  diagram(
    node-stroke: 1pt,
    node-shape: fletcher.shapes.rect,
    ..args,
  )
}
#let start-node = node.with(corner-radius: 2pt, extrude: (0, 3), outset: 3pt)
#let branch-node = node.with(shape: fletcher.shapes.diamond.with(fit: 0.7))
#let hackbr-node(pos, content, ..args) = node(
  pos,
  block(inset: (bottom: 1mm), spacing: 0em, align(center, content)),
  shape: fletcher.shapes.diamond,
  ..args,
)

#figure(caption: "Обобщённый алгоритм унификации")[
  #flowchart(
    start-node((0, 0), [Старт]),
    edge("-|>"),
    node((0, 1), [Сбор требований]),
    edge("-|>"),
    branch-node((0, 2), [Присутствуют \ невозможные \ требования?]),
    edge("l,d,d", "-|>", [Да]),
    node((-1, 4), [Унификация \ невозможна]),
    edge((0, 2), (0, 3), "-|>", [Нет]),
    node((0, 3), [Объединение требований]),
    edge("-|>"),
    hackbr-node((0, 4), [Найдены\ противоречия?]),
    edge("-|>", [Нет]),
    edge((0, 4), (-1, 4), "-|>", [Да]),
    node((1, 4), [Унификация успешна]),
  )
]

=== Унификация чистых типовых выражений

При отсутствии зависимых типов, проблема унификации решаема в общем виде, хотя и нетривиальна. Выражение, возвращающее тип является в такой ситуации либо обращением к типу по имени, либо вызовом обобщенного типа с несколькими аргументами, которые представляют собой другие типовые выражения.

#figure(caption: "Иллюстрация чисто типовых выражений")[
  ```idris
  -- Обращение к типу Nat по имени
  a : Nat
  -- Вызов обобщённого типа List c аргументом Nat
  b : List Nat
  -- Пример более сложного вызова обобщённого типа
  c : SortedMap (List String) (IO Int)
  ```
]

Равенство двух обращений к типу по имени эквивалентно равенству имён, а равенство двух вызовов обобщённого типа -- равенству обобщённого типа и всех переданных ему аргументов. Таким образом, два типовых выражения равны тогда и только тогда, когда они полностью соответствуют друг другу.

#figure(caption: "Алгоритм поиска требований при отсутствии зависимых типов")[
  #flowchart(
    start-node((0, 0), [Старт]),
    edge("-|>"),
    branch-node((0, 1), [Свободные\ переменные?]),
    edge("l", "-|>", [Обе]),
    edge("r", "-|>", [Одна], label-pos: 0.25),
    edge("d", "-|>", [Нет]),
    node((-1.5, 1), [Свободные \ переменные \ должны быть \ равны друг другу]),
    node((1.5, 1), [Свободная \ переменная \ должна быть\ равна значению]),
    hackbr-node((0, 2), [Типы\ совпадают?]),
    edge("-|>", [Да]),
    hackbr-node((0, 3), [Тип \ выражения?]),
    edge((0, 3), (-1.5, 3), "-|>", [Вызов]),
    edge("d", "-|>", [Переменная]),
    node((-1.5, 3), [Собрать требования\ аргументов]),
    edge((-1.5, 3), (-2.5, 3), (-2.5, 0), (-0.23, 0), "-|>"),
    branch-node((0, 4), [Равны между\ собой?]),
    edge("l", "-|>", [Да]),
    edge((1.5, 4), "-|>", [Нет]),
    node((-1.5, 4), [Нет требований]),
    node((1.5, 4), [Противоречие]),
  )
]

Соответственно, унификация типовых выражений может накладывать на свободные переменные всего два вида требований -- равенство другой переменной и равенство выражению.

После нахождения всех условий, начинается процесс их объединения. Он состоит из двух частей. В первую очередь, переменные группируются на основе равенства друг другу. Так как все условия, применимые к переменной, по определению применимы ко всем переменным, им равным, это единственный способ собрать все ограничения, которые действуют на каждую конкретную переменную.

Затем происходит поиск противоречий в этих условиях. Если на каждую переменную действует не более одного условия, то противоречий нет по определению. Иначе, необходимо для каждой пары условий равенства выражению, действующих на переменную, произвести поиск условий равенства её выражений. Затем необходимо добавить полученные условия о равенстве переменных друг другу к уже имеющимся и заменить имеющиеся условия о равенстве переменных выражениям на новые. Этот шаг повторяется, пока не будет найдено противоречие (в случае чего фординг возвращает его), или пока его применение не перестанет изменять данные условия. В таком случае, полученный набор условий является финальным.

#figure(caption: "Алгоритм объединения требований при отсутствии зависимых типов")[
  #flowchart(
    // debug:3,
    start-node((0, 0), [Старт]),
    edge("-|>"),
    node((0, 1), [Объединение по переменным]),
    edge("-|>"),
    branch-node((0, 2), [Есть переменные\ с $>1$ требований?]),
    edge("d", "-|>", [Нет]),
    edge("l", "-|>", [Да]),
    node((-1, 2), [Выведение новых\ требований]),
    edge("d", "-|>"),
    branch-node((-1, 3), [Противоречия?]),
    edge("l,uu,rr", "-|>", [Нет], label-pos: 0.15),
    edge("d", "-|>", [Да]),
    node((-1, 4), [Унификация невозможна]),
    node((0, 3), [Финальные требования]),
  )
]

Получив финальный набор требований, можно приступить к выведению значений переменных. Для этого строится граф зависимости переменных (вернее, граф зависимости множеств взаимно равных переменных). В случае наличия циклов в графе, унификация невозможна, и алгоритм завершается. В случае отсутствия циклов, можно вычислить значения переменных.

Это происходит в рамках итеративного алгоритма. На каждой итерации, находятся вершины графа, которые не зависят ни от одной другой вершины. Их значения подставляются в выражения всех вершин, которые от них зависят, и зависимости удаляются. Алгоритм завершается, когда ни одна вершина не зависит от другой.

Получившиеся в результате подстановки выражения -- финальные значений переменных, которые возвращаются в результате унификации.

=== Унификация зависимых типов
Присутствие зависимых типов расширяет множество классов выражений, которые могут встречаться при унификации. Назовём любое выражение, использующее в качестве своих аргументов значения зависимым выражением. Такие выражения включают в себя не только вызов обобщённых типов с параметрами-значениями, но и ветвление, вызовы функций, локальные объявления, и прочие выражения, для которых суждение о результате до их выполнения трудно или невозможно.

Более того, при отсутствии зависимых типов свободная переменная могла иметь только одно корректное значение (или, в случае зависимости от другой, неопределенной свободной переменной, заменялась в конструкторе на одно выражение). Зависимые типы же позволяют тривиально привести пример, при котором это не так.

#figure(caption: "Пример зависимого типа, для которого унификация не решается однозначно")[
  ```idris
  data ExampleType : Nat -> Nat -> Type where
    ExampleCon : (x : Nat) -> ExampleType x (x `mod` 2)

  ex1 : ExampleType 5 1
  ex1 = ExampleCon 5

  ex2 : ExampleType 20 0
  ex2 = ExampleCon 20

  -- Как мономорфизировать (ExampleType x 1)?
  -- Такой тип существует только при x % 2 == 1!
  ```
]

Таким образом, при появлении зависимых выражений, типичная реализация унификации и обработки её решений перестаёт работать.
=== Фординг

Тем не менее, благодаря возможности выражать произвольные логические утверждения через зависимые типы, существует способ обойти проблему унификации зависимых выражений. Он заключается в переносе доказательства возможности или невозможности унификации с момента мономорфизации типа на момент использования конкретного мономорфного конструктора путём включения типа, обозначающего искомое равенство в качестве аргумента этого конструктора.

Поскольку в интуиционистской логике построение равноценно доказательству, такой конструктор можно будет использовать тогда и только тогда, когда для всех условий построения предоставлено доказательство.

#figure(caption: "Пример мономорфизации зависимого типа с фордингом и его использования")[
  ```idris
  data MVect : Nat -> Type -> Type where
    N : MVect 0 t
    MCons : t -> MVect n t -> MVect (S n) t

  data MVect1 : Type -> Type where
    MCons1 : t -> MVect n t -> (S n) = 1 => MVect1 t

  data MVect0 : Type -> Type where
    N0 : MVect0 t
    MCons0 : t -> MVect n t -> (S n) = 0 => MVect0 t

  to1 : MVect 1 t -> MVect1 t
  to1 (MCons x xs) = MCons1 x xs @{Refl}

  from1 : MVect1 t -> MVect 1 t
  from1 (MCons1 x xs @{pf}) = rewrite sym pf in MCons x xs

  to0 : MVect 0 t -> MVect0 t
  to0 N = N0
  to0 (S n) impossible

  from0 : MVect0 t -> MVect 0 t
  from0 N0 = N
  from0 (MCons0 x xs @{pf}) = rewrite sym pf in MCons x xs
  ```
]

Такой подход обладает своими недостатками. В первую очередь, фординг усложняет использование сгенерированных мономорфных типов, требуя доказательств. Во-вторых, с помощью фординга нельзя сгенерировать инфраструктуру для типов, которые содержат выражения, возвращающего разные обобщенные типы (а не просто разные его версии) в зависимости от входных данных. В-третьих, фординг может приводить к генерации неоптимальных мономорфных типов (лишние условия и т.д.). В-четвертых, фординг может приводить к появлению параметров из сигнатуры типа в конструкторе, чего не случается при его отсутствии.

Несмотря на это, фординг остаётся единственным способом корректно мономорфизировать некоторые зависимые GADT, т.к. задача унификации зависимых выражений в общем случае нерешаема.
== Заключение по второй главе

В данной главе описан алгоритм мономорфизации зависимых типов. Разобраны в деталях задача унификации типовых выражений и её решение. Описана процедура фординга условий, применяемых к нетиповым подвыражениям, её преимущества и недостатки.

#chapter[Реализация и тестирование алгоритма]

== Средства реализации

Язык Idris2 обладает широким набором возможностей, связанных с метапрограммированием. Основным интерфейсом, через который оно в нём осуществляется, является монада `Elab`. Как и многие другие монады в языках с функциональным программированием, `Elab` выражает операцию с побочными эффектами -- получением информации об объявленных типах и переменных и о текущем пространстве имён, объявлении новых переменных и toplevel-деклараций, и записи текста в логи компилятора.

Функции, возвращающие в качестве результата монаду `Elab`, называются скриптами элаборатора. Для их применения используется директива компилятора `%runElab`. При её обработке, компилятор приостанавливает работу, вычисляет значение монады `Elab`, переданной в директиву, и выполняет описанную ей операцию. Директива `%runElab` может быть использована как в виде toplevel-декларации в случае, где вычисление не возвращает результата, так и в виде значения внутри выражения, где результат вычисления подставляется на место директивы.

#figure(caption: "Пример скрипта элаборатора и его использования")[
  ```idris
  -- Выводит сообщение в лог
  basicELS' : Elab ()
  basicELS' = logMsg "basic" 0 "Hello world!"

  -- Проверяет, существует ли переменная с данным названием
  basicELS : Name -> Elab Bool
  basicELS n = do
    -- Получить информацию о всех переменных с таким названием
    ts <- getType n
    -- Записать сообщение в лог
    logMsg "basicELS" 0 "Hello World again!"
    -- Проверить, пустой ли список, вернуть результат
    pure $ (length ts) > 0

  -- Вызов в виде toplevel-декларации
  %runElab basicELS'

  -- Вызов как часть выражения
  elsTest : Bool
  elsTest = %runElab basicELS `{test}
  ```
]

Монада `Elab` и другие типы и функции, связанные с метапрограммированием, являются частью стандартной библиотеки Idris2 и располагаются в пространстве имён `Language.Reflection`.

Однако стандартная библиотека Idris2 предоставляет только примитивные средства метапрограммирования. Одна из областей, требующих абстракций, реализованных на основе стандартной библиотеки -- сбор информации о сигнатурах символов, параметрах и конструкторах типов. Для решения этих задач используется библиотека `elab-util`, содержащая различные вспомогательные функции для метапрограммирования.

== Реализованный функционал и особенности реализации

Описанный алгоритм мономорфизации типов был реализован в виде метапрограммы (скрипта элаборатора) на языке Idris2.

#figure(caption: [Сигнатура и использование функции мономорфизации])[
  ```idris
  -- Полностью мономорфизировать тип List с аргументом String
  %runElab monomorphise (List String) "ListString"

  -- Частично мономорфизировать тип SortedMap
  %runElab monomorphise (\t => SortedMap Nat t) "SortedMapNat"
  ```
]

#figure(caption: [Архитектура программы])[
  #flowchart(
    debug: 3,
    spacing: (10mm, 5mm),
    node((-1, 0), [Сбор требований\ к переменным], name: <collecteq>),
    node((-1, 1), [Разрешение зависимостей\ между переменными], name: <depgraph>),
    node((-1, -0.8), [Унификация выражений], stroke: none, name: <unilabel>),
    node(enclose: (<collecteq>, <depgraph>, <unilabel>), name: <unigroup>),
    node((0,-0.8), [Подстановка переменных], stroke: none, name: <sublabel>),
    node((0,0), [Сбор информации\ о затенении], name: <iozat>),
    node((0,1), [Сбор информации\ о квотировании], name: <ioquot>),
    node(enclose: (<iozat>, <ioquot>, <sublabel>), name: <subgroup>),
    edge(<unigroup>, <subgroup>, "-|>"),
  )
]
=== Подстановка переменных

Неотъемлемой частью мономорфизации и унификации является алгоритм подстановки значений переменной в выражение.

Поскольку выражения во внутреннем представлении языка Idris2 представляют собой деревья из значений взаимно рекурсивных типов, для такой манипуляции выражением необходим его рекурсивный обход. Стандартная библиотека Idris2 предоставляет несколько функций, позволяющих применять трансформации различной сложности к внутреннему представлению выражений. Самая мощная из них -- `mapATTImp'` -- позволяет применить к каждой вершине внутреннего представления монадическую трансформацию, способную предоставлять контекст и изменять результаты трансформациям её потомков. Этот интерфейс предоставляет собой монадический аналог Visitor-паттерна.

При подстановке значения переменной необходимо знать, указывает ли имя в определённом контексте на данную переменную. Такого может не происходить в двух случаях: квотировании и затенении.

Квотирование -- возможность использовать определённым образом отмеченные выражения языка Idris2 в качестве литералов их внутреннего представления. Внутри квотированных выражений имена не указывают ни на какие переменные, за исключением выражений, находящихся внутри оператора подстановки.

Затенение -- свойство языка, где при объявлении среди предков выражения нескольких переменных с одинаковым именем приоритет отдаётся объявленной глубже переменной.

Сбор информации о квотировании и затенении -- функционал, необходимый в других частях реализации, поэтому он был вынесен в отдельные функции, а информация об объявленных квотировании и затенении -- в отдельные трансформаторы монад, основанные на монаде `Reader`.

Итого, для реализации использовался монадический Visitor-паттерн в сочетании с двумя трансформаторами монад, собиравшими в процессе обхода внутреннего представления информацию об объявленных переменных и квотировании.

=== Унификация типовых выражений

Реализация унификации в целом соответствует алгоритму, описанному во второй главе. Для сбора условий используется взаимно рекурсивный спуск по внутреннему представлению выражений. При спуске сохраняется промежуточное состояние унификации -- хранятся множества переменных, равных друг другу, выражения, которым они равны, и список равенств, подлежащих фордингу.

Фазы сбора и разрешения требований ради простоты реализации и более быстрого обнаружения противоречий были объединены в один взаимно рекурсивный процесс. Как только один и тот же набор переменных оказывается равен двум подвыражениям, происходит рекурсивный вызов функции унификации для этих подвыражений, и условия их равенства добавляются к имеющимся.

После вычисления финального результата унификации, происходит подстановка этих результатов в равенства, подлежащие фордингу.

=== Генерация кода

На основе полученных в результате унификации условий и значений переменных, из конструктора опускаются аргументы, значения которых известны, а их вызовы в сигнатуре возвращаемого типа заменяются на эти значения. Также к аргументам конструктора добавляются доказательства равенств, подлежащих фордингу. Получившиеся таким образом конструкторы снова собираются в мономорфный тип, который является основным результатом работы алгоритма.

Следующий шаг генерации кода -- выведение функций конвертирования. Выводятся их сигнатуры вида "Для любого значения набора параметров типа существует функция конвертации значений такого типа". При реализации функции каждому конструктору мономорфного типа сопоставляется конструктор полиморфного типа.

#figure(caption: "Пример сгенерированной функции конвертации")[
  ```idris
  castM2P : (n : Nat) => VectNat n -> Vect n Nat
  castM2P [] = []
  castM2P (x::xs) = (x::xs)

  %hint
  castImpl : (n : Nat) => Cast (Vect n Nat) (VectNat n)
  castImpl = MkCast castM2p
  ```
]

На основании функции конвертации становится возможным реализация для мономорфного типа ряда интерфейсов, реализованных для полиморфного типа. Каждая такая реализация принимает в качестве Implicit-параметров все параметры мономорфного типа, а также реализацию интерфейса для полиморфного типа. Реализация методов интерфейса для мономорфного типа сводится к конвертированию его значений в значения полиморфного типа и применению методов интерфейса для полиморфного типа к ним.

#figure(caption: "Пример реализации интерфейса Show")[
  ```idris
  showImpl : (n : Nat) => Show (Vect n Nat) => Show VectNat n
  showImpl = MkShow (show . cast) (\_, x => show $ cast x)
  ```
]

Автоматическое выведение реализации интерфейса `DecEq` -- значительно сложнее, поскольку для его реализации необходима формулировка доказательства равенства.  

== Тестирование алгоритма мономорфизации

Предполагается тестирование алгоритма двумя способами: Unit-тестированием и End-to-end тестированием.

В случае Unit-тестирования предполагается тестирование компонентов алгоритма, не являющихся метарпограммами в своей на корректность их отдельной работы. В данный момент алгоритм подстановки переменной в выражении покрыт набором unit-тестов на предмет его работоспособности и семантической корректности. Unit-тесты реализованы с помощью порта библиотеки Property-based тестирования `hedgehog` на язык программирования Idris2.

Однако для компонент проекта, являющихся метапрограммами, классическое unit-тестирование невозможно. Скрипты элаборатора работают во время компиляции, и ошибки в них приводят к ошибкам компиляции.

Для тестирования их работоспособности используется end-to-end тестирование. Каждый отдельный тест представляет собой программу на языке Idris2, для которой проверяются успешные компиляция и выполнение программы.

== Дальнейшее развитие

Возможные дальнейшие направления развития проекта включают:

+ Добавление глубокого анализа выражений для оптимизации условий, сгенерированного с помощью фординга. В настоящий момент любое зависимое выражение подлежит фордингу. Однако, существует ряд типов выражений, такие как блок `let ... in`, для которых возможен более детальный анализ.
+ Частичную или полную реализацию поддержки рекурсивных типов.
+ Интеграция мономорфизатора в библиотеку DepTyCheck.
+ Использование автоматических инструментов тестирования.

== Заключение по третьей главе

В данной главе описаны средства и процесс реализации и тестирования алгоритма, приведены особенности реализации, описаны возможности по дальнейшему развитию проекта.

#heading(level: 1, numbering: none)[ЗАКЛЮЧЕНИЕ]
В результате выполнения выпускной квалификационной работы был разработан алгоритм мономорфизации зависимых GADT и создана реализация этого алгоритма на языке Idris2.

Были выполнены поставленные задачи:
1. Ознакомиться с существующими алгоритмами мономорфизации типов
2. Выделить среди множества нерекурсивных зависимых типов классы типов, для которых мономорфизация возможна и практична
3. Разработать алгоритм мономорфизации для этих типов
4. Реализовать этот алгоритм в виде метапрограммы для языка Idris2
5. Произвести тестирование алгоритма

#bib-page("sources.bib")
